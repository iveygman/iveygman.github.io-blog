<p>One of my favorite tricks in C and C++ is messing around with bit-twiddling. That is, screwing around with bitwise operators like AND, OR or XOR to achieve some neat effect. One of the more popular (and useful) tricks exploits a property of XOR to swap int values in-place. How does it work? Like this:</p>

<pre><code>int a = 1, b = 2;
cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
a = a ^ b;	// step 1
b = b ^ a;	// step 2
a = a ^ b;	// step 3
cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
</code></pre>

<p>This prints</p>

<pre><code>1 2
2 1
</code></pre>

<p>Why does this work? It’s because of the properties of exclusive-or in Boolean algebra. Recall the truth-table for exclusive-or:</p>

<pre><code>    | 0   1  
 ---|--------
  0 | 0   1 
  1 | 1   0 
</code></pre>

<p>For any value, <code>A</code>, this means that <code>A XOR A == 0</code>. In the first stage of the swap, we set <code>a = a ^ b</code>. This means that in the second stage, <code>b ^ a</code> is effectively the same as <code>b ^ a ^ b</code>. Because exclusive-or is also associative, that is <code>A XOR B == B XOR A</code>, Therefore, <code>b ^ a</code> is equivalent to <code>b ^ b ^ a</code>, which, from associativity, is simply <code>a</code>. This is why we do step 1 – it sets up <code>a</code> as a masked variable with <code>b</code>.</p>

<p>In step 3, we need to recover the original value of <code>b</code> similarly to get our new value of <code>a</code>. Since <code>b</code> now has the original value of <code>a</code> and <code>a</code> is <code>a ^ b</code>, this becomes equivalent to <code>a = a ^ b ^ b</code>, which, with <code>b</code>’s new value, is the same as <code>a ^ b ^ a</code>.</p>

<p>The whole point of this confusing-looking formula is to avoid temporary variables altogether. However, as an illustrative example, let’s see how this looks with a temporary variable <code>x</code>:</p>

<pre><code>int a = 1, b = 2, x;
cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
x = a ^ b;	// step 1
b = b ^ x;	// step 2 (b now has original value of a)
a = x ^ b;	// step 3 (a now has original value of b)
cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
</code></pre>

<h4 id="standard-c">Standard C++</h4>

<p>Since C++11, you can now use <code>std::swap</code> as a fast, reliable way to swap the values of any two variables of the same type. This may be a better approach for many since the above XOR-method doesn’t work for <code>float</code> or many other types of data. It also happens to be faster! The below test program (compiled using clang++ on a Macbook Pro running Yosemite) yields this XOR approach taking 9.5ms while <code>std::swap</code> takes 3.9ms for 1,000,000 iterations each.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;

using namespace std;

void intswap(int *a, int *b) {
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}

int main(int argc, char **argv) {


    int one = 1, two = 2;
    chrono::time_point&lt;chrono::system_clock&gt; start, end;
    chrono::duration&lt;long double&gt; elapsed;

    // use our swap
    start = chrono::system_clock::now();
    for (int i = 0; i &lt; 1000000; i++) {
        one ^= two;
        two ^= one;
        one ^= two;
    }
    end = chrono::system_clock::now();
    elapsed = end - start;

    cout &lt;&lt; "XOR swap took " &lt;&lt; elapsed.count() &lt;&lt; endl;

    start = chrono::system_clock::now();
    for (int i = 0; i &lt; 1000000; i++) {
        std::swap(one,two);
    }
    end = chrono::system_clock::now();
    elapsed = end - start;
    cout &lt;&lt; "std::swap took " &lt;&lt; elapsed.count() &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>What this means is that you should use <code>std::swap</code> whenever it’s available, but the XOR trick can be useful for swapping stuff in-place on systems that either don’t have C++11 or are very lightweight.</p>
